\vspace{-0.2in}
\section{Introduction}
\vspace{-0.1in}

Smartphones are ubiquitous: we are witnessing an astonishing growth in mobile phone subscriptions. The International Telecommunication Union estimates there are nearly 7 billion mobile subscriptions worldwide. Meanwhile, the mobile phones' sensors (e.g., cameras) are advancing and the network bandwidth is constantly increasing. Consequently, every person with a mobile phone can now act as a multi-modal sensor, collecting and sharing various types of high-fidelity spatiotemporal data instantaneously (e.g., picture, video, audio, location, time, speed, direction, and acceleration).

Exploiting this large crowd of potential workers and their mobility, a new mechanism for efficient and scalable data collection has emerged: Spatial Crowdsourcing (SC) \cite{Kazemi12}. Spatial crowdsourcing requires workers (e.g., willing individuals) to perform a set of tasks by physically traveling to certain locations at particular times. Spatial crowdsourcing is exploited in numerous industries, e.g., Uber, TaskRabbit, Waze, Gigwalk, etc., and has applications in numerous domains such as citizen-journalism, tourism, intelligence, disaster response and urban planning. With spatial crowdsourcing, a requester submits a set of spatiotemporal tasks to a spatial crowdsourcing server (SC-Server). Subsequently, the SC-Server has to select a worker to perform each task.

Different studies on spatial crowdsourcing \cite{Kazemi12,Li15,Deng15,Chen15,Cheng16,Fonteles15,Guo16} can be classified based on two basic characteristics of the problem; (1) whether the problem \textit{matches} a task with a worker and (2) whether the problem \textit{schedules} matched tasks for the workers. Early studies in SC \cite{Kazemi12,Fonteles15,Cheng16} used a \textit{scheduling-oblivious-matching (SOM)} approach where tasks are matched with workers without considering the workers' schedule. Assuming the tasks have already been matched with workers, other studies. \cite{Deng13,Li15} study the problem of  scheduling the tasks that have been assigned to a worker. They show that there is no guarantee that the worker could schedule all of its matched tasks. We argue that with Spatial Crowdsourcing, it is not enough to only \textit{match} a task with a worker. An SC-Server must consider the \textit{schedule} of every worker when matching a task to workers and only consider those workers who are able to fit the task in their schedule. In this paper, we define the task assignment problem in SC consisting of two phases, a matching phase and a scheduling phase, which need to happen in tandem. Neither of these phases should be ignored, otherwise, the resulting solution is rendered infeasible for real-world applications.

More recent studies consider both matching and scheduling in spatial crowdsourcing \cite{Deng15,Chen15,Guo16}. These studies utilize a \textit{batched assignment} scheme, where the assignment is delayed for a period of time (i.e., batching time interval) during which all the arrived tasks are batched to be matched and scheduled during the next time interval. Once the tasks are batched and processed together, suddenly the matching phase becomes complex because many tasks need to be matched to many workers. This in turn adds to the running time and increases the batching time interval. 
%Consequently, neither studies can support real-time assignments.

%(3) whether the problem requires \textit{real-time} results where the task requester is notified within a few seconds whether his task will be executed or not. For example, an Uber user requesting a ride, does not want to wait for 10 minutes to find out if a driver is available or not.

A long batching time interval (e.g., 10 minutes) has two main disadvantages.  First, the duration of the batching time interval should be subtracted from the tasks' deadline, leaving each task with less available time to be scheduled. Second, batch scheme can no longer generate real-time assignments. While there might be cases where a real-time assignment is not required, there are many other real-world applications where real-time assignments are a necessity; For example, an Uber user requesting a ride, does not want to wait for 10 minutes to find out if a driver is available or not. Contrary to batched assignment, in \textit{online assignment}, a task is assigned to a worker as soon as it arrives at the SC-Server. This requires the server to perform matching and scheduling in real-time. With online assignment, at each point of time the SC-Server is processing only one task and hence, the matching phase becomes a one-to-many matching where there are multiple workers and only one task. Consequently, the complex many-to-many matching phase of batched assignment is reduced to only selecting the best worker that can fit the task in its schedule. Even though matching is fast with online assignment, the server must still perform scheduling for multiple workers. Therefore, the scheduling phase becomes the bottleneck in online assignment. As shown in \cite{Li15}, scheduling for a single worker can be performed fast. However, an online monolithic\cite{Stephens15} SC-Server (monolithic-SC), where the server has to schedule only a single task for \emph{all} workers, is not capable of processing tasks in real-time. For example, in New York City, during rush hours, there are as many as 10+ ride requests per second \cite{NYCTaxi}. Through experiments, we show that monolithic-SC is not able to support such throughput in real-time. Towards this end, we propose Auction-SC: an auction-based framework for real-time task matching and scheduling. Similar to monolithic-SC, Auction-SC is an online framework where tasks get matched with workers as soon as they become available and hence, the matching phase is fast. Moreover, we overcome the scheduling bottleneck by distributing it among the workers.

With Auction-SC, the server broadcasts a task to the workers upon the task's arrival. Each worker\footnote{Hereafter, we use the term "worker" interchangeably to refer to both the human worker and the software running on her mobile device unless clear distinction is needed.} submits a bid for that task based on its current schedule and location. To compute its bid, each worker has to consider only its own schedule so the bid computation phase can be done in real-time. Once every worker submits its bid to the SC-Server, matching the task to a worker reduces to selecting the highest bid.

We introduce a branch-and-bound scheduling algorithm where for each new task, the worker performs an exhaustive search to find out whether it can fit the incoming task into its schedule. We show that at each point of time the number of remaining tasks for each worker (the number of tasks that the worker has scheduled and not completed yet) is in a range that even the branch-and-bound algorithm can be completed in real-time. However, in our experiments, we show that even replacing the branch-and-bound algorithm with a polynomial time approximate algorithm, will not affect the quality of the assignment significantly.

In addition to the branch-and-bound algorithm, we propose a more complex bidding technique that considers the probability of a task appearing in a spatial region in the future. The key idea is that having more workers in areas where there is a higher chance of having tasks in the future, can increase the quality of the assignment. This consideration increases the complexity of the bid computation phase such that it may impact the scalability of the framework. However, we show that the SC-Server can still manage a throughput of \textasciitilde 50 tasks per second with this complex bidding technique.

We conduct many experiments on both real-world and synthetically generated workloads to evaluate different aspects of Auction-SC. For our real world data we use two geo-social datasets (Gowalla \& Foursquare). First, we show that compared to Auction-SC, both the SOM and batched approach result in a much lower assignment rate as a result of ignoring scheduling while matching and long batching intervals, respectively. Subsequently, we show that when matching and scheduling are performed in tandem, neither the batched scheme nor the online monolithic SC-Server can process more than 5 tasks per second. However, with the auction based framework, the throughput of the system increases by orders of magnitude.

In sum, the contributions of this paper are as follows:

\begin{itemize}
\item We formally define the \textit{online} task assignment problem in SC and analyze its complexity.
\item We introduce the Auction-SC framework as a scalable solution for the online task assignment problem in SC. 
\item We propose a novel algorithm for computing bids in Auctions-SC where both the spatial and temporal dynamism of SC are considered.
\item Through experiments on real-world and synthetic data, we show Auction-SC outperforms alternative approaches in the number of completed tasks and scalability.
\end{itemize}
%\item Through various experiments on real-world and synthetic data, we show (1) a larger number of tasks are completed with Auction-SC as compared to both the batched and SOM approaches and (2) unlike Auction-SC, neither the batched nor the online Monolithic-SC approaches can scale to real-world requirements.

The remainder of this paper is organized as follows. In \cref{sec:prelim} we formally define the online task assignment problem in SC and discuss its complexity. We review the related work in \cref{sec:related}. We introduce Auction-SC in \cref{sec:onlinealgo} and propose a novel bidding rule within the auction-based framework. We show the results of our experiments on both real-world and synthetic data in \cref{sec:experiments} and conclude the paper with guidelines for future work (\cref{sec:future}).