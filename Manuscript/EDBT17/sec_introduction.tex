\section{Introduction}

Smartphones are ubiquitous: we are witnessing an astonishing growth in mobile phone subscriptions. The International Telecommunication Union estimates there are nearly 7 billion mobile subscriptions worldwide \cite{Mobiforge14}. Meanwhile, the mobile phones' sensors (e.g., cameras) are advancing and the network bandwidth is constantly increasing. Consequently, every person with a mobile phone can now act as a multi-modal sensor, collecting and sharing various types of high-fidelity spatiotemporal data instantaneously (e.g., picture, video, audio, location, time, speed, direction, and acceleration).

Exploiting this large crowd of potential workers and their mobility, a new mechanism for efficient and scalable data collection has emerged: Spatial Crowdsourcing (SC) \cite{Kazemi12}. Spatial crowdsourcing requires workers (e.g., willing individuals) to perform a set of tasks by physically traveling to certain locations at particular times. Spatial crowdsourcing is exploited in numerous industries, e.g., Uber, TaskRabbit, Waze, Gigwalk, etc., and has applications in numerous domains such as citizen-journalism, tourism, intelligence, disaster response and urban planning. With spatial crowdsourcing, a requester submits a set of spatiotemporal tasks to a spatial crowdsourcing server (SC-Server). Subsequently, the SC-Server has to select a worker to perform each task.

With Spatial Crowdsourcing, it is not enough to only \textit{match} a task with a worker. An SC-Server must consider the \textit{schedule} of every worker when matching a task to workers and only consider those workers who are able to fit the task in their schedule. For example in \cite{Kazemi13,Alfarrarjeh15} the focus is on matching tasks with workers and the workers' schedule is ignored. On the other hand, Deng et. al. \cite{Deng13} consider scheduling tasks for a single worker while assuming the tasks have already been matched. They show there is no guarantee that the worker is going to be able to schedule all its matched tasks. In this paper, we define the task assignment in SC consisting of two phases, a matching phase and a scheduling phase, which need to happen in tandem. Neither of these phases should be ignored, otherwise, the resulting solution is rendered infeasible for real-world applications.

Two recent studies consider both matching and scheduling in spatial crowdsourcing \cite{Deng15, Chen15}. However, neither studies can provide real-time assignments. This is because in order to match a task to the best worker, the server has to perform the scheduling phase for multiple workers. Scheduling multiple workers is time consuming and cannot be done in real-time. Consequently, both studies utilize a \textit{batched assignment} scheme, where the assignment is delayed for a period of time (i.e., batching time interval) during which all the arrived tasks are batched to be matched and scheduled during the next time interval. That is, while the SC-Server is busy processing a set of tasks, the next batch of tasks arrive at the server. Once the server completes the previous batch, it starts processing those tasks that have been queued. Once the tasks are batched and processed together, suddenly the matching phase becomes complex because many tasks need to be matched to many workers. This in turn, adds to the running time and increases the batching time interval.

A long batching time interval (e.g., 10 minutes) has two main disadvantages.  First, the duration of the batching time interval should be subtracted from the tasks' deadline, leaving each task with less available time to be scheduled. Second, batch scheme can no longer generate real-time assignments which is the requirement of many SC applications. For example, an Uber user wants to know if there is a driver that can service her as soon as she submits the request. Instead in \textit{online assignment}, a task is assigned to a worker as soon as it arrives at the SC-Server. This requires the server to perform matching and scheduling in real-time. With online assignment, at each point of time the SC-Server is processing only one task and hence, the matching phase becomes a one-to-many matching where there are multiple workers and only one task. Consequently, the complex many-to-many matching phase of batched assignment is reduced to only selecting the best worker that can fit the task in its schedule. Even though matching is fast with online assignment, the server has to still perform scheduling for multiple workers. Therefore, the scheduling phase becomes the bottleneck in online assignment. As shown in \cite{Li15}, scheduling for a single worker can be done fast. However, a \textcolor{red}{monolithic} SC-Server \cite{Stephens15}, where the server has to perform scheduling for all workers, is not capable of processing tasks in real-time. For example, in New York City, during rush hours, there are as many as 10+ ride requests per second \cite{NYCTaxi}. Through experiments, we show that a \textcolor{red}{monolithic} SC-Server is not able to support such throughput in real-time. Towards this end, we propose Auction-SC; an auction-based framework for real-time task matching and scheduling. In this framework, we the scheduling bottleneck by utilizing the workers.

With Auction-SC, the server broadcasts a task to the workers upon the task's arrival. Each worker\footnote{Hereafter, we use the term "worker" interchangeably to refer to both the human worker and the software running on her mobile device unless clear distinction is needed.} submits a bid for that task based on its current schedule and location. To compute its bid, each worker has to consider only its own schedule so the bid computation phase can be done in real-time. Once every worker submits its bid to the SC-Server, matching the task to a worker reduces to selecting the best bid.

%In a real-world SC scenario, the server will find out about a task and its properties only when it is released. At this time, the SC-Server should either immediately assign the task to a worker (online assignment) or wait for more tasks to arrive and assign all the recently assigned tasks at once (batched assignment). Due to the complexity of task assignment in SC, almost every prior work uses the batched schema. This allows the server to complete processing the current batch while it waits for the next batch to arrive. For example, 

%For example the more tasks the server processes at the same time, the more information it has and hence it can provide better results. It is for this reason that \cite{Kazemi13, Alfarrarjeh15} deploy the batched schema. Even though both studies ignore the scheduling responsibilities of the SC-Server, they still have to perform a many-to-many matching where there are multiple workers and multiple tasks.

%Finding the best worker to assign a task in real-time becomes a major challenge once there is a large number of tasks and workers. Task assignment in SC consists of a matching phase and a scheduling phase that have to be done simultaneously. It is not enough to only \textit{match} a task with a worker. In addition to matching tasks and workers, an SC-Server must also compute a \textit{schedule} for every worker and assign a task to a worker who can reach to and perform the task before its expiration time. Moreover, the process must be performed frequently and in real-time as new tasks and workers become available or as tasks are completed (or expired) and workers leave the system.

%Several existing approaches \cite{Kazemi12,Deng13,Cheng15,Li15,Alfarrarjeh15} have focused on the task assignment problem in SC. To achieve scalability, instead of a real-time assignment upon the task's arrival, Kazemi and Shahabi \cite{Kazemi12} wait for multiple tasks to arrive and process them together (batched assignment). As a result, the SC-Server will have enough time to process the current batch of tasks while it is waiting for the next batch to arrive. Alfarrarjeh et. al. \cite{Alfarrarjeh15} distribute the arriving tasks on multiple SC-Servers but still fall short of a real-time task assignment. In addition to not being real-time, the SC-Server does not compute a schedule for workers prior to the assignment. Each worker checks to see if she can fit a task in her schedule once the task is already assigned to her. Deng et. al. \cite{Deng13} consider the problem of scheduling assigned tasks for a single worker and show that in many cases it is not possible to schedule all tasks that have been assigned to a worker. Two recent studies \cite{Li15,Deng15} match and schedule tasks simultaneously. Deng et. al. \cite{Deng15} perform a batched-assignment. We show how a batched-assignment cannot achieve the same level of quality as an \textit{online assignment} where tasks get assigned to workers as soon so they arrive in the system. Li et. al. \cite{Li15} are the first to perform online assignment in SC. However, they only perform it for a single worker and to the best of our knowledge, real-time matching and scheduling is a problem yet to be solved.

%The key challenge for an SC-Server deploying the online assignment schema is performing scheduling for potentially a large number of workers at real-time. As shown in \cite{Li15}, a centralized SC-Server is not capable to accomplish this. Towards this end, we propose Auction-SC; an auction-based framework for real-time task matching and scheduling. In this framework, we decentralize the scheduling problem by utilizing the workers. The SC-Server broadcasts a task to the workers upon the task's arrival. Each worker \footnote{Hereafter, we use the term "worker" interchangeably to refer to both the human worker and the software running on her mobile device unless clear distinction is needed.} submits a bid for that task based on her current schedule and location. To compute her bid, each worker has to consider only her own schedule so the bid computation phase can be done in real-time. Once every worker submits her bid to the SC-Server, matching the task to a worker reduces to selecting the best bid.

We introduce a branch-and-bound scheduling algorithm where for each new task, the worker performs an exhaustive search to find out whether it can fit the incoming task into its schedule. We show that at each point of time the number of remaining tasks for each worker (the number of tasks that the worker has scheduled and not completed yet) is in a range that even the branch-and-bound algorithm can be completed in real-time. However, in our experiments, we show that even replacing the branch-and-bound algorithm with a polynomial time approximate algorithm, will not affect the quality of the assignment significantly.

In addition to the branch-and-bound algorithm, we propose a more complex bidding technique that takes into consideration the spatial distribution of the tasks seen so far. The key idea is that having more workers in areas with more tasks can increase the quality of the assignment. This consideration increases the complexity of the bid computation phase such that it may impact the scalability of the framework. However, we show that the SC-Server can still manage a throughput of \textcolor{red}{\textasciitilde 200} tasks per second with this complex bidding technique.

%With a real-world SC system, the SC-Server does not know about the time and location of future tasks and workers, until they arrive. Therefore, it is impossible for the SC-Server to generate a globally optimal assignment. As a benchmark to better evaluate the quality of the real-time assignments made by Auction-SC, for the first time, we propose an algorithm for finding the globally optimal assignment in an SC environment. We assume there exists a clairvoyant which knows exactly at what time and which location new tasks and workers will arrive and for how long they will be available. We prove that the clairvoyant algorithm is computationally expensive and cannot be performed on large workloads with thousands of tasks and workers. However, in our experiments, for small workloads, we compare the results of Auction-SC with the globally optimal assignment.

We conduct many experiments on both real-world and synthetically generated workloads to evaluate different aspects of Auction-SC. For our real world data we use two geo-social datasets (Gowalla \& Foursquare). We show that with a monolithic SC-Server cannot process more than 5 tasks per second. However, with the auction based framework, the throughput of the system can go as high as \textcolor{red}{200} tasks per second. 

%The remainder of this paper is organized as follows. In \cref{sec:prelim} we formally define the task assignment problem in SC and prove it is NP-Complete. We review the related work in \cref{sec:related}. Next, we propose our offline clairvoyant algorithm in \cref{sec:exactalgo} and analyze its time complexity. We introduce Auction-SC in \cref{sec:onlinealgo} and propose several bidding rules within the auction-based framework. We show the results of our experiments on both real world and synthetic data in \cref{sec:experiments} and conclude the paper with guidelines for future work (\cref{sec:future}).

The remainder of this paper is organized as follows. In \cref{sec:prelim} we formally define the online task assignment problem in SC and discuss its complexity. We review the related work in \cref{sec:related}. We introduce Auction-SC in \cref{sec:onlinealgo} and propose several bidding rules within the auction-based framework. We show the results of our experiments on both real-world and synthetic data in \cref{sec:experiments} and conclude the paper with guidelines for future work (\cref{sec:future}).