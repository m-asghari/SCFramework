\section{Non-Clairvoyant Algorithm}

Auction methods have been effectively used for assignment problems in dynamic multi-agent environments \cite{Mehta05,Lagoudakis04}. In these methods, each worker (agent) places a bid on each task and task assignment is achieved by a process similar to winner determination in auctions. One key advantage of auction-based assignment is that each worker can compute its own bid independent of every other worker. Therefore a great portion of the computation can be decentralized which in turn helps to whole process to scale faster. In this section we introduce a generic framework for auction-based task assignment in spatial crowdsourcing and introduce a variety of bidding rules based on different heuristics.\\

Our auction-based framework considers the workers as bidders and tasks as goods, and operates as follows. Upon arrival of each task, it performs one round of bidding. During each round of bidding, all robots bid on the task. Depending on the bidding rule, the worker with the overall highest/lowest bid wins and is assigned to that particular task. Upon assignment of a new task, each worker updates its path based on the task(s) that it has been assigned to and moves along that path.\\

The main advantage of this auction-based mechanism is its simplicity and, as mentioned earlier, the fact that it allows for a decentralized implementation for each worker. Each worker only needs to know its own location, the location of the new task but not the location of any other worker. In each round, each worker computes its single bid locally and in parallel with the other workers and reports the bid the the \textit{SC server}. The server, which plays the role of a central auctioneer, chooses the winning worker and assigns the task to it. It is worth to mentions the low cost of communication in our framework; each worker submits only one number to the server i each round of bidding. In addition, workers do not have to share their own location with any other entity (including the server) which preserves their privacy.\\

\begin{algorithm}
\caption{OnlineTASC($W, t$)}
\label{algo:OnlineTASC}
\begin{algorithmic}[1]
\REQUIRE $W$ is the set of currently available workers and $t$ is a task the has just released
\ENSURE Either $w \in W$ as the worker task $t$ should be assigned to or \emph{null} if no worker is selected
\STATE $w_{selected} = $ \emph{null}
\STATE $Bids = \emptyset$
\FOR{$w \in W$}
	\STATE $bid = w$.ComputeBid$(t)$
	\STATE $Bids \leftarrow \left\langle w, bid \right\rangle$
\ENDFOR
\STATE $w_{selected} = $ SelectBestBid$(Bids)$
\RETURN $w_{selected}$
\end{algorithmic}
\end{algorithm}

\cref{algo:OnlineTASC} outlines the process of assigning a task $t$ in our framework once $t$ arrives. Notice that all iterations of the \textbf{for} loop in \cref{algo:OnlineTASC} (lines 3-6) can run in parallel. The \emph{ComputeBid()} method (line 4) that each worker executes depends on the bidding rule we choose. Similarly, the \emph{SelectBestBid()} method (line 7) returns the worker with either the highest or lowest bid. In case of a tie, the \emph{SelectBestBid()} method, randomly selects one worker among the ones with optimum bid.\\

In the remainder of this section, we will discuss different heuristics for bidding. First we will introduce four commonly used heuristics that perform well in the Online Matching Problem, Online Traveling Salesman Problem and Online Scheduling Problem (Provide References). For each heuristic we will describe how each worker will compute its bid for each task and how the server chooses the winner after all workers submit their bids. For all the following bidding rules, if the worker is not able to perform a task it will submit a \textit{null} bid. For example, if the worker does not have enough time to complete the new task in addition to its current schedule, it will make a \textit{null} bid for that task. Then we will introduce a new heuristic where workers take into account the spatial distribution of available workers and the tasks when computing their bids. The goal is make the distribution of available workers as close as possible to the overall distribution of tasks so that once future tasks arrive, there's a higher chance that a worker will be available at a close proximity.

\begin{itemize}

\item \textbf{Nearest Neighbor}

Similar to the \textit{Nearest Neighbor Priority Strategy} in \cite{Kazemi12}, for this bidding rule we give priority to workers that are closer to the location of the task. The idea is that if the workers have to travel less, then they can finish the task sooner and have more free time to dedicate to future tasks. To compute a bid, each worker needs to compute the distance between the location of the task and its own location. Once every worker has submitted its bid, the server chooses the worker with the minimum bid as the winner and assigns the task to it.

\item \textbf{Best Insertion}

We already mentioned that, intuitively, if a worker travels less to complete a task it will likely have more time for performing other tasks. In \cref{subsec:problemdef} we noted at each point of time, each worker has an ordered list of tasks as its schedule. For this bidding rule, we give priority to workers that can better insert the current task into their schedule. Here we consider the \textit{additional} time each worker will need to complete the new task in addition to the incomplete tasks already assigned to it.\\
In order to compute a bid, each worker finds the finish time of its current schedule $(f_1)$ and its finish time in case the task is added to their schedule $(f_2)$. Then the worker's bid will be $f_2 - f_1$. In order to compute $f_2$ the worker will not simply add the new task to the end of its current schedule and find the finish time. Rather, it will find a new schedule consisting of all tasks in its current schedule plus the new task.
Once every worker submits its bid, the server will assign the task to the worker with the lowest bid.

\item \textbf{Most Remaining Time}

One can argue that the more available workers there are once a task arrives, the higher the chance of that task getting assigned. The \textit{Nearest Neighbor} and \textit{Best Insertion} bidding rules where trying to achieve this goal, by choosing workers that could complete the task by dedicating the least amount of time so they have more of their time to dedicate to future tasks. However, workers will not be available after their deadline. Therefore, in addition to how much time a worker has to dedicate for a new task, it is also important how much free time will it will have if the task is assigned to it.\\
To make a bid, each worker finds its finish time in case the new task is added to its schedule $(f)$. This is similar to computing $f_2$ for the \textit{Best Insertion} rule. Each worker will submit a bid equal to $w.d - f$. Unlike the previous two bidding rules, in this case, the higher the bid the better. Therefore, after receiving all bids, the server will assign the task to the worker with the highest bid.

%\item \textbf{Best Distribution}

%The general idea behind this heuristic is to try to move workers to locations where there is a higher chance for future tasks to be located around. Ideally, we want the spatial distribution of the \textit{current} workers $(S_W)$. to be as close as possible to the \textit{overall} spatial distribution of the tasks $(S_T)$.\\
%One can argue that knowing $S_T$ contradicts the assumption that the SC server has no spatiotemporal knowledge about future tasks. However, even if the server knows $S_T$ doesn't mean it also knows the exact location where the task is going to be released. Even if we don't want the server to know $S_T$ as a priori, we can assume that the server starts with an empty distribution and keeps updating it as new tasks arrive. During each round of bidding, the server shares the most updated version of $S_T$ with workers.\\
%We show a spatial distribution using a grid and count the number of events in each cell. By normalizing the counts, we can come up with the probability of an event occurring in each cell.

\end{itemize}

\subsection{Best Distribution Heuristic}

The general idea behind this heuristic is to try to move workers to locations where there is a higher chance for future tasks to be located around. Ideally, we want the spatial distribution of the \textit{current} workers $(S_W)$. to be as close as possible to the \textit{overall} spatial distribution of the tasks $(S_T)$.\\
One can argue that knowing $S_T$ contradicts the assumption that the SC server has no spatiotemporal knowledge about future tasks. However, even if the server knows $S_T$ doesn't mean it also knows the exact location where the task is going to be released. Even if we don't want the server to know $S_T$ as a priori, we can assume that the server starts with an empty distribution and keeps updating it as new tasks arrive. During each round of bidding, the server shares the most updated version of $S_T$ with workers.\\
We show a spatial distribution using a grid and count the number of events in each cell. By normalizing the counts, we can come up with the probability of an event occurring in each cell.\\